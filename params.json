{
  "name": "task.js",
  "tagline": "JavaScript library for building and running tasks.",
  "body": "# [task.js](https://github.com/manjeshbhargav/task.js.git)\r\n\r\n`task.js` is a JavaScript library for creating logical groups of instructions called `tasks`. These tasks leverage the `Promise` pattern to allow application logic to specify when a task is `done(result)` or `failed(reason)`.\r\n\r\n## Advantages over direct `Promise`s\r\n* You don't have to promisify your async functions that use callbacks.\r\n* However, you can safely use `Promise`s within tasks.\r\n* You can leverage APIs to run a sequence of tasks, or try the same task multiple times etc.\r\n* You can give a human readable name to your tasks thereby improving code readability.\r\n* These tasks can be easily testable with `Promise` based frameworks like `mocha.js`.\r\n\r\n## Installation\r\n\r\n* For `Node.js` or `browserify/webpack` projects\r\n    ```\r\n    npm install lib-task\r\n    ```\r\n    ```javascript\r\n    var Task = require('lib-task');\r\n    ```\r\n\r\n* For standard web projects\r\n    ```\r\n    git clone https://github.com/manjeshbhargav/task.js.git\r\n    ```\r\n    ```\r\n    cd task.js && npm run build\r\n    ```\r\n    Then, you can use `./dist/task.js` or `./dist/task.min.js` in your web project using `<script>`.\r\n\r\n## Task `template`\r\nA `template` is basically a `function` that defines the set of instructions that the task will be performing. It follows this format:\r\n```javascript\r\n/**\r\n * A task template.\r\n * @param {...*} taskArguments - Arguments for executing the task.\r\n * @param {function} done - Called (with results, if any) by the task when it's done.\r\n * @param {function} failed - Called (with errors, if any) by the task whe it fails.\r\n * @returns {*}\r\n */\r\nfunction template(...taskArguments, done, failed) {\r\n  ...\r\n  ...\r\n  doSomeAsyncTask(args, done, failed);\r\n}\r\n```\r\n\r\n## Creating a task\r\nYou can create a task like this:\r\n```javascript\r\nvar loginAttempt = Task.create('attempting to log in', function(endpoint, credentials, done, failed) {\r\n  var username = credentials.username;\r\n  var password = credentials.password;\r\n  // Using JQuery AJAX to contact the login endpoint\r\n  $.post({\r\n    url: endpoint,\r\n    data: { u: username, p: password },\r\n    success: function(response) { done(JSON.parse(response)); },\r\n    failure: failed\r\n  });\r\n});\r\n```\r\n\r\nHere, `endpoint` and `credentials` are the arguments required for doing the task. In this example, `done()` is called when the login\r\n`endpoint` responds with a success `JSON` message, and `failed()` is called when it responds with the reason for the failure.\r\n\r\nThere are other ways to specify when the task is `done/failed`:\r\n\r\n* `return`ing a value: A task is considered `done` if the `template` `return`s any non-`Promise` value, and `failed` if it throws an exception.\r\n  ```javascript\r\n  var addTask = Task.create('add two numbers', function(a, b) {\r\n    return (a + b);\r\n  });\r\n  ```\r\n\r\n* `return`ing a `Promise`: A task is considered `done/failed` if the `Promise` returned by the `template` is `resolved/rejected`.\r\n  ```javascript\r\n  var promiseTask = Task.create('track a promise', function(a, b) {\r\n    ...\r\n    ...\r\n    return someAsyncFunctionThatReturnsAPromise(a, b);\r\n  });\r\n  ```\r\n\r\n## Executing a task\r\nThe `loginAttempt` task that was created in the previous section can be executed like this:\r\n```javascript\r\nloginAttempt.do('/services/login', {\r\n  usename: 'johndoe',\r\n  password: 'xyz123'\r\n}).then(function(success) {\r\n  console.log('Login successful! - ', success);\r\n}).catch(function(error) {\r\n  console.error('Login failed! - ', error);\r\n});\r\n```\r\nHere, the argument passed to `done()` is passed on to the `Promise`'s `then()` callback, while the argument passed to `failed()` is passedon to the `catch()` callback.\r\n\r\n* `addTask` from the previous section can be executed like this:\r\n  ```javascript\r\n  addTask.do(2, 3).then(function(sum) {\r\n    // sum is the return value of addTask's template.\r\n    console.log('Sum is - ', sum);\r\n  }).catch(function(e) {\r\n    console.error('Exception thrown while executing template - ', e); \r\n  });\r\n  ```\r\n\r\n* `promiseTask` from the previous section can be executed like this:\r\n  ```javascript\r\n  promiseTask.do('a', 'b').then(function(result) {\r\n    console.log('Promise returned by the template was resolved with - ', result);\r\n  }).catch(function(error) {\r\n    console.error('Promise returned by the template was rejected with - ', error);\r\n  });\r\n  ```\r\n\r\n## Executing tasks serially\r\nSometimes we need to perform a set of tasks serially, where the next task depends on the result from the previous task.\r\nWe can do it like this:\r\n```javascript\r\nvar task1 = Task.create('task1', function(a, b, done, failed) {...});\r\nvar task2 = Task.create('task2', function(task1Result, done, failed) {...});\r\nvar task3 = Task.create('task3', function(task2Result, done, failed) {...});\r\n\r\nTask.sequence([task1, task2, task3], ...argsForTask1).then(function(task3Result) {\r\n  console.log('Result of task3 - ', task3Result);\r\n}).catch(function(error) {\r\n  console.error('One of the tasks failed - ', error);\r\n});\r\n```\r\n\r\n## Executing tasks in parallel\r\nSometimes we need to wait for a set of independent tasks to be executed before we can proceed. We can do it like this:\r\n```javascript\r\nvar task1 = Task.create('task1', function(a, b, done, failed) {...});\r\nvar task2 = Task.create('task2', function(d, e, f, done, failed) {...});\r\nvar task3 = Task.create('task3', function(done, failed) {...});\r\n\r\nTask.parallel([\r\n  task1.do(1, 2),\r\n  task2.do('3', true, {}),\r\n  task3.do()\r\n]).then(function(taskResults) {\r\n  console.log('Results of all tasks - ', taskResults);\r\n}).catch(function(error) {\r\n  console.error('One of the tasks failed - ', error);\r\n});\r\n```\r\n\r\n## Executing an anonymous task\r\nSometimes we don't want to create and then do a task because it is one-off and we don't intend to re-do it at any point in the future. We can do it like this:\r\n```javascript\r\nTask.do(function(a, b, done, failed) {\r\n  startMyApplication(a, b, function(started, result) {\r\n    var status = started ? done : failed;\r\n    status(result);\r\n  });\r\n}, 1, '2').then(function(outcome) {\r\n  console.log('Application successfully started! - ', outcome);\r\n}).catch(function(error) {\r\n  console.error('Problem starting application! - ', error);\r\n});\r\n```\r\n\r\n## Re-trying a task\r\nSometimes we want to try a task a number of times until it succeeds, or we've tried a certain number of times.\r\nEx: If we lose our connection with the server, we would want to re-try connecting for a certain number of times.\r\nWe can do it like this:\r\n```javascript\r\nvar numRetries = 10;\r\nvar retryConnection = Task.create('retry connecting to server', function(request, done, failed) {\r\n  request.connect('/server/connect', function(response) {\r\n    if (response.connection) { done(response.connection); }\r\n    else { failed(response.error); }\r\n  });\r\n});\r\n\r\nfunction retryConnect() {\r\n  Task.try(retryConnection, numRetries, new Request()).then(function(connection) {\r\n    console.log('Connected! - ', connection);\r\n    connection.on('lost', retryConnect);\r\n  }).catch(function(error) {\r\n    console.error('Failed to connect after ' + numRetries + ' tries! - ', error);\r\n  });\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}