{
  "name": "task.js",
  "tagline": "JavaScript library for building and running tasks.",
  "body": "# [task.js](https://github.com/manjeshbhargav/task.js.git)\r\n\r\n[![npm version](https://badge.fury.io/js/lib-task.svg)](https://badge.fury.io/js/lib-task)\r\n[![Travis CI](https://travis-ci.org/manjeshbhargav/task.js.svg)](https://travis-ci.org/manjeshbhargav/task.js.svg)\r\n[![Lincense MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://img.shields.io/badge/License-MIT-blue.svg)\r\n\r\n`task.js` is a JavaScript library for creating logical groups of instructions called `tasks`. These tasks leverage the `Promise`\r\npattern to allow application logic to specify when a task is `done(result)` or `failed(reason)`.\r\n\r\n## Advantages over direct `Promise`s\r\n* You don't have to promisify your async functions that use callbacks.\r\n* However, you can safely use `Promise`s within tasks.\r\n* Powerful APIs to execute a group of tasks, or the same task a number of times.\r\n* You can give a human readable name to your tasks thereby improving code readability.\r\n* These tasks can be easily testable with `Promise` based frameworks like `mocha.js`.\r\n\r\n## Installation\r\n\r\n* For `Node.js` or `browserify/webpack` projects\r\n    ```\r\n    npm install lib-task\r\n    ```\r\n    ```javascript\r\n    var Task = require('lib-task');\r\n    ```\r\n\r\n* For standard web projects\r\n    ```\r\n    git clone https://github.com/manjeshbhargav/task.js.git\r\n    ```\r\n    ```\r\n    cd task.js && npm run build\r\n    ```\r\n    Then, you can use `./dist/task.js` or `./dist/task.min.js` in your web project using `<script>`.\r\n\r\n## Task `template`\r\nA `template` is basically a `function` that defines the set of instructions that the task will be performing. It follows this format:\r\n```javascript\r\n/**\r\n * A task template.\r\n * @param {...*} taskArguments - Arguments for executing the task.\r\n * @param {function} done - Called (with results, if any) by the task when it's done.\r\n * @param {function} failed - Called (with errors, if any) by the task when it fails.\r\n * @returns {*}\r\n */\r\nfunction template(...taskArguments, done, failed) {\r\n  ...\r\n  ...\r\n  doSomeAsyncTask(args, done, failed);\r\n}\r\n```\r\n\r\n## Creating a task\r\nYou can create a task like this:\r\n```javascript\r\nvar loginAttempt = Task.create('attempting to log in', function(endpoint, credentials, done, failed) {\r\n  var username = credentials.username;\r\n  var password = credentials.password;\r\n  // Using JQuery AJAX to contact the login endpoint\r\n  $.post({\r\n    url: endpoint,\r\n    data: { u: username, p: password },\r\n    success: function(response) { done(JSON.parse(response)); },\r\n    failure: failed\r\n  });\r\n});\r\n```\r\n\r\nHere, `endpoint` and `credentials` are the arguments required for doing the task. In this example, `done()` is called when the login\r\n`endpoint` responds with a success `JSON` message, and `failed()` is called when it responds with the reason for the failure.\r\n\r\nThere are other ways to specify when the task is `done/failed`:\r\n\r\n* `return`ing a value: A task is considered `done` if the `template`\r\n  `return`s any non-`Promise` value, and `failed` if it throws an exception.\r\n  ```javascript\r\n  var addTask = Task.create('add two numbers', function(a, b) {\r\n    return (a + b);\r\n  });\r\n  ```\r\n\r\n* `return`ing a `Promise`: A task is considered `done/failed` if the\r\n  `Promise` returned by the `template` is `resolved/rejected`.\r\n  ```javascript\r\n  var promiseTask = Task.create('track a promise', function(a, b) {\r\n    ...\r\n    ...\r\n    return someAsyncFunctionThatReturnsAPromise(a, b);\r\n  });\r\n  ```\r\n\r\n## Executing a task\r\nThe `loginAttempt` task that was created in the previous section\r\ncan be executed like this:\r\n```javascript\r\nloginAttempt.do('/services/login', {\r\n  usename: 'johndoe',\r\n  password: 'xyz123'\r\n}).then(function(success) {\r\n  console.log('Login successful! - ', success);\r\n}).catch(function(error) {\r\n  console.error('Login failed! - ', error);\r\n});\r\n```\r\nHere, the argument passed to `done()` is passed on to the `Promise`'s\r\n`then()` callback, while the argument passed to `failed()` is passed\r\non to the `catch()` callback.\r\n\r\n* `addTask` from the previous section can be executed like this:\r\n  ```javascript\r\n  addTask.do(2, 3).then(function(sum) {\r\n    // sum is the return value of addTask's template.\r\n    console.log('Sum is - ', sum);\r\n  }).catch(function(e) {\r\n    console.error('Exception thrown while executing template - ', e); \r\n  });\r\n  ```\r\n\r\n* `promiseTask` from the previous section can be executed like this:\r\n  ```javascript\r\n  promiseTask.do('a', 'b').then(function(result) {\r\n    console.log('Promise returned by the template was resolved with - ', result);\r\n  }).catch(function(error) {\r\n    console.error('Promise returned by the template was rejected with - ', error);\r\n  });\r\n  ```\r\n\r\n## Canceling a task\r\nSometimes we need to cancel a task after starting it. We can do it like this:\r\n```javascript\r\nvar timeout = null;\r\nvar task = Task.create('cancelable task', function(ms, done, failed) {\r\n  timeout = setTimeout(function() { failed('Timeout over!'); }, ms);\r\n});\r\n\r\ntask.do(5000).then(function() {...}).catch(function(reason) {\r\n  if (reason === 'canceled') {\r\n    console.log('We are here because the task was actively canceled.');\r\n  }\r\n  else {\r\n    console.log('We are here because the task failed().');\r\n  }\r\n  clearTimeout(timeout);\r\n  timeout = null;\r\n});\r\n\r\n// The argument to cancel() is anything that we want to\r\n// pass to the Promise's catch() that helps us determine why it\r\n// was rejected.\r\ntask.cancel('canceled');\r\n```\r\n\r\n## Timing out a task\r\nSometimes we want to set a time limit for a task to complete (`done()` or `failed()`). We can do it like this:\r\n```javascript\r\nvar xhr = new XMLHttpRequest();\r\nvar getUrl = Task.create('get content of url', function(url, done, failed) {\r\n  xhr.open('GET', url, true);\r\n  xhr.onreadystatechange = function() {\r\n    if (xhr.status === 200 && xhr.readyState === 4) {\r\n      done(xhr.responseText);\r\n    }\r\n  };\r\n  xhr.send();\r\n});\r\n\r\n// The second argument to timeout() is anything that we want to\r\n// pass to the Promise's catch() that helps us determine why it\r\n// was rejected.\r\ngetUrl.timeout(5000, { reason: 'timeout' });\r\n\r\ngetUrl.do('http://www.x.y.com/?a=b').then(function(response) {\r\n  console.log('Response: ', response);\r\n}).catch(function(error) {\r\n  if (error.reason === 'timeout') {\r\n    console.log('Task timed out.');\r\n  }\r\n  xhr.abort();\r\n});\r\n```\r\n\r\n## Executing tasks serially\r\nSometimes we need to perform a set of tasks serially, where the next task depends on the result from the previous task.\r\nWe can do it like this:\r\n```javascript\r\nvar task1 = Task.create('task 1', function(task1Arg, done, failed) {...});\r\nvar task2 = Task.create('task 2', function(task1Result, done, failed) {...});\r\nvar task3 = Task.create('task 3', function(task2Result, done, failed) {...});\r\nvar taskSequence = Task.sequence('sequence', [task1, task2, task3]);\r\n\r\n// The arguments of Task#do() are arguments for the first task in the sequence.\r\ntaskSequence.do(10).then(function(task3Result) {\r\n  console.log('All done one after the other!');\r\n}).catch(function(error) {\r\n  console.error('One of the tasks failed - ', error);\r\n});\r\n```\r\n\r\n## Executing tasks in parallel\r\nSometimes we need to wait for a set of independent tasks to be executed before we can proceed. We can do it like this:\r\n```javascript\r\nvar task1 = Task.create('task1', function(arg1, done, failed) {...});\r\nvar task2 = Task.create('task2', function(arg21, arg22, done, failed) {...});\r\nvar task3 = Task.create('task3', function(arg31, done, failed) {...});\r\nvar taskParallel = Task.parallel('parallel', [task1, task2, task3]);\r\n\r\n// The arguments for Task#do() is (args1, args2, args3), where:\r\n// * args1 => Array of arguments for task1's template\r\n// * args2 => Array of arguments for task2's template\r\n// * args3 => Array of arguments for task3's template\r\n// NOTE: If there is only one argument for a task, then there is no\r\n//       need to enclose it in an array.\r\ntaskParallel.do(1, ['2', true], {}).then(function(results) {\r\n  console.log('Results of all completed tasks - ', results);\r\n}).catch(function(error) {\r\n  console.error('One of the tasks failed - ', error);\r\n});\r\n```\r\n\r\n## Executing an anonymous task\r\nSometimes we don't want to create and then do a task because it is one-off and we don't intend to re-do it at any point in the\r\nfuture. We can do it like this:\r\n```javascript\r\nTask.do(function(a, b, done, failed) {\r\n  startMyApplication(a, b, function(started, result) {\r\n    var status = started ? done : failed;\r\n    status(result);\r\n  });\r\n}, 1, '2').then(function(outcome) {\r\n  console.log('Application successfully started! - ', outcome);\r\n}).catch(function(error) {\r\n  console.error('Problem starting application! - ', error);\r\n});\r\n```\r\n\r\n## Re-trying a task\r\nSometimes we want to try a task a number of times until it succeeds, or we've tried a certain number of times.\r\nEx: If we lose our connection with the server, we would want to re-try connecting for a certain number of times.\r\nWe can do it like this:\r\n```javascript\r\nvar numRetries = 10;\r\nvar retryConnection = Task.try('retry connecting to server', function(request, done, failed) {\r\n  request.connect('/server/connect', function(response) {\r\n    if (response.connection) { done(response.connection); }\r\n    else { failed(response.error); }\r\n  });\r\n});\r\n\r\nfunction retryConnect() {\r\n  retryConnection.do(new Request(), numRetries).then(function(connection) {\r\n    console.log('Connected! - ', connection);\r\n    connection.on('lost', retryConnect);\r\n  }).catch(function(error) {\r\n    console.error('Failed to connect after ' + numRetries + ' tries! - ', error);\r\n  });\r\n}\r\n```\r\n\r\n# Running a task for each item in an array\r\nSometimes we want to run a task on each item of an array, and once we have gotten all the results,\r\nact on them (like `Array.prototype.map()`, only async). We can do it like this:\r\n```javascript\r\nvar getHtmlMap = Task.map('get html of a given url', function(url, done, failed) {\r\n  http.get(url, function(response) {\r\n    var html = '';\r\n    response.on('data', function(data) {\r\n      html += data;\r\n    });\r\n    response.on('end', function() {\r\n      done(html);\r\n    });\r\n  }).on('error', failed);\r\n});\r\n\r\n// The argument for Task#do() is an array where the task has to be\r\n// performed once for each item in parallel.\r\ngetHtmlMap.do(['http://www.ex1.com', 'http://www.ex2.com']).then(function(htmls) {\r\n  htmls.forEach(function(html, i) {\r\n    console.log('HTML[\"' + domains[i] + '\"]: ', html);\r\n  });\r\n}).catch(function(error) {\r\n  console.log('Failed to get htmls - ', error);\r\n});\r\n```\r\n\r\n# Delayed execution of a task\r\nSometimes we want to execute a task after a certain period of time. We can do it like this:\r\n```javascript\r\nvar delayedTask = Task.delay('check status after 5 seconds', function(url, done, failed) {\r\n  $.getJSON(url, done, failed);\r\n});\r\n\r\n// The last argument to Task#do() is the wait time in milliseconds.\r\ndelayedTask.do('http://www.x.y.com/status/me', 5000).then(function(status) {\r\n  console.log('Status: ', status);\r\n}).catch(function(error) {\r\n  console.log('Failed to get status: ', error);\r\n});\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}